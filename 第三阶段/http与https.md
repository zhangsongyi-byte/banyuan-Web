# http与https

基于TCP协议。

(transmission Control Protocol，传输控制协议)，简单来说是在收发数据前，必须建立可靠的连接。

与之相对的，有一个叫做UDP协议。

（User Data Protocol，用户数据报协议），简单来说是在收发数据前不建立可靠连接，也就是说，传送的数据可能丢失（丢包）。常用于实时的音频与视频。





### http：（80端口）

全称：HyperText Transfer Protocol

是一个客户端请求( request )和服务器端应答 ( response )的标准（tcp），用于在互联网上传输数据

http传输的数据都是未加密的，就是明文的信息，不安全。



### https：（443端口） 

全称：Hyper Text Transfer Protocol over SecureSocket Layer

简单来说，就是安全版本的http

因为http的明文特性，SSL（Secure Scoket Layer）/ TLS(Transport Layer Security)传输层安全协议，用来加密http协议传输的数据，从而诞生了https。



#### 上面的所谓端口号是什么？

端口号的主要作用是表示一台计算机中的特定进程所提供的服务。网络中的计算机是通过IP地址来代表其身份的，它只能表示某台特定的计算机，但是一台计算机上可以同时提供很多个服务，如数据库服务、FTP服务、Web服务等，我们就通过端口号来区别相同计算机所提供的这些不同的服务，如常见的端口号21表示的是FTP服务，端口号23表示的是Telnet服务端口号25指的是SMTP服务等。端口号一般习惯为4位整数，在同一台计算机上端口号不能重复，否则，就会产生端口号冲突



### 3次握手，4次挥手：

3次握手的作用就是为了服务器端和客户端明确自己和对方的收发能力是否正常。



#### 第一次握手：

客户端发送网络包，服务器端收到后，服务器端得到结论，客户端发送能力是正常的。



#### 第二次握手：

服务器端发包，客户端收到，客户端知道了服务器端正常。包括发送和接受能力。



#### 第三次握手：

客户端发包，服务器端收到，服务端知道，客户端的接受能力也是正常的。



### tips：

三次握手过程中，能否携带数据？

第一次和第二次是不能携带数据的。原因是为了防止攻击，同时在前两次还没确定可不可以发送数据，发送数据是没有意义的。





### 4次挥手：

建立连接需要3次握手，那么终止连接需要经过4次挥手。其原因是http中，是半关闭的，在一端在关闭了它自己的发送后还能有接受数据的能力。



假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，“告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，“告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，“就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！



#### 第一次挥手：

客户端发送报文，停止发送数据，主动关闭链接，进入等待状态，等待服务器的确认。



#### 第二次挥手：

服务端收到报文后，发包到客户端，表示收到了客户端停止发包的消息。即，发送了确认报文，服务端进入关闭等待状态。



#### 第三次挥手：

如果服务端也想关闭了，和客户端一样，发送报文

#### 第四次挥手：

同第二次挥手。





### 长链接和短链接：

**长连接：** 客户端和服务端建立连接后不进行断开，之后客户端再次访问这个服务器上的内容时，继续使用这一条连接通道。

**短连接：** 客户端和服务端建立连接，发送完数据后立马断开连接。下次要取数据，需要再次建立连接。



tips：

在HTTP/1.0中，默认使用的是短连接。但从 HTTP/1.1起，默认使用长连接。在服务器端，会设置一个较短的连接时间，短的过期时间优势是可以快速传输多个web页面组件。



至今还有http1.0吗？

https://stackoverflow.com/questions/2073392/is-http-1-0-still-in-use

https://zh.wikipedia.org/wiki/HTTP/2

https://www.baidu.com/



### 前端通过url去连接后端：

和 [Hypertext](https://developer.mozilla.org/zh-CN/docs/Glossary/Hypertext) 以及 [HTTP](https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP) 一样，**URL**是Web中的一个核心概念。它是[浏览器](https://developer.mozilla.org/zh-CN/docs/Glossary/浏览器)用来检索web上公布的任何资源的机制。

**URL指的是统一资源定位符（***Uniform Resource Locator***）**。URL无非就是一个给定的独特资源在Web上的地址。理论上说，每个有效的URL都指向一个独特的资源。这个资源可以是一个HTML页面，一个CSS文档，一幅图像，等等。

https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/What_is_a_URL



### get与post的区别：

get是幂等的，而post不是。

什么是幂等？

不管你调用多少次，都不会出现不同结果的http方法。

| 分类             | GET                                                          | POST                                                         |
| :--------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 后退按钮/刷新    | 无害                                                         | 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。     |
| 书签             | 可收藏为书签                                                 | 不可收藏为书签                                               |
| 缓存             | 能被缓存                                                     | 不能缓存                                                     |
| 编码类型         | application/x-www-form-urlencoded                            | application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 |
| 历史             | 参数保留在浏览器历史中。                                     | 参数不会保存在浏览器历史中。                                 |
| 对数据长度的限制 | 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 | 无限制。                                                     |
| 对数据类型的限制 | 只允许 ASCII 字符。                                          | 没有限制。也允许二进制数据。                                 |
| 安全性           | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 |
| 可见性           | 数据在 URL 中对所有人都是可见的。                            | 数据不会显示在 URL 中。                                      |





### get方法的长度限制：

一句话，http协议标准并没有限制，是浏览器实现标准的时候为了性能和安全性考虑自己定义的，即，的确有长度限制，但http并没有定义。



### 常见的请求方式：(Restful)

| 方式    | 作用                                             |
| ------- | ------------------------------------------------ |
| GET     | 请求获取资源                                     |
| POST    | 更新数据                                         |
| PUT     | 要求存储一个数据                                 |
| DELETE  | 要求删除数据                                     |
| OPTIONS | 请求查询服务器性能，或查询与资料相关的选项和需求 |



### 状态码：

由3位数字组成，第一个数字定义了响应的类别。

1xx：指示信息 --- 表示请求已接受，在继续处理

2xx： 成功 --- 表示请求已接收

3xx：重定向 --- 要完成请求必须有进一步的操作

4xx：客户端错误 --- 请求语法错误活着请求无法实现

5xx：服务端错误 --- 服务端未能实现合法的请求



### 常见的状态吗：

| 状态码 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| 200    | （Ok）成功                                                   |
| 301    | （Moved Permanently）请求的文档在其他地方，新的url在location头重给出，浏览器将会自动访问新的url （永久） |
| 302    | （Moved Temporarily）请求的文档在其他地方，新的url在location头重给出，浏览器将会自动访问新的url （暂时） |
| 400    | （Bad Request）请求出现语法错误                              |
| 401    | （Unauthorized）浏览器试图未经授权访问受密码保护的页面       |
| 403    | （Forbidden）资源不可用，服务器端理解客户的请求，但是拒绝处理它。 |
| 404    | （Not Found）无法找到指定位置的资源                          |
| 500    | （ Internal Server Error）服务器出现意料之外的情况，不能完成客户的请求。 |
| 502    | （Bad Gateway）服务器作为网关或者代理时候，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。 |
| 503    | （Service Unavailable）服务器由于维护活着负载过重未能应答    |
| 504    | （Gateway Timeout）由作为代理或者网关使用，表示超时。        |



### http1.x与http2.0区别：

**多路复用 (Multiplexing)**

多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。在 HTTP/1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一，拿 Twitter 为例，http://twimg.com，目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。而 HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。



**二进制分帧**

HTTP/2在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段的情况下, 解决了HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。

HTTP/2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。在过去， HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。

这种单连接多资源的方式，减少服务端的链接压力,内存占用更少,连接吞吐量更大；而且由于 TCP 连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少,使拥塞和丢包恢复速度更快。



**首部压缩（Header Compression）**

HTTP/1.1并不支持 HTTP 首部压缩，为此 SPDY 和 HTTP/2 应运而生， SPDY 使用的是通用的DEFLATE 算法，而 HTTP/2 则使用了专门为首部压缩而设计的 HPACK 算法。

**服务端推送（Server Push）**

服务端推送是一种在客户端请求之前发送数据的机制。在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应。Server Push 让 HTTP1.x 时代使用内嵌资源的优化手段变得没有意义；如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源，不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。

