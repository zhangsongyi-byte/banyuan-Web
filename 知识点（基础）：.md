# 知识点（基础）：

1. ### css盒子模型

   ```
   盒模型都是由四个部分组成的，分别是margin、border、padding和content。
   
   标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content。
   
   一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。
   ```

   

2. ### 块级元素，行内元素，行内块元素

   ```
   HTML4 中，元素被分成两大类: inline （内联元素）与 block（块级元素）。一个行内元素只占据它对应标签的边框所包含的空
   间。
   
   常见的行内元素有 a b span img strong sub sup button input label select textarea
   
   块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。
   
   常见的块级元素有  div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p 
   ```

3. ### 行内元素与块级别元素的区别

   ```
   （1） 格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。
   （2） 内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。
   （3） 行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 width 无效，height 无效（可以设置 line-height），设置 margin 和 padding 的上下不会对其他元素产生影响。
   ```

4. ### link标签

   ```
   link 标签定义文档与外部资源的关系。
   
   link 元素是空元素，它仅包含属性。 此元素只能存在于 head 部分，不过它可出现任何次数。
   
   link 标签中的 rel 属性定义了当前文档与被链接文档之间的关系。常见的 stylesheet 指的是定义一个外部加载的样式表。
   ```

5. ### css选择器

   ```
   （1）id选择器（#myid）
   （2）类选择器（.myclassname）
   （3）标签选择器（div,h1,p）
   （4）后代选择器（h1 p）
   （5）相邻后代选择器（子）选择器（ul>li）
   （6）兄弟选择器（li~a）
   （7）相邻兄弟选择器（li+a）
   （8）属性选择器（a[rel="external"]）
   （9）伪类选择器（a:hover,li:nth-child）
   （10）伪元素选择器（::before、::after）
   （11）通配符选择器（*）
   ```

6. ### CSS 优先级算法

   ```
   CSS的优先级是根据样式声明的特殊性值来判断的。
   
   选择器的特殊性值分为四个等级，如下：
   
   （1）标签内选择符x,0,0,0
   （2）ID选择符0,x,0,0
   （3）class选择符/属性选择符/伪类选择符	0,0,x,0
   （4）元素和伪元素选择符0,0,0,x
   
   计算方法：
   
   （1）每个等级的初始值为0
   （2）每个等级的叠加为选择器出现的次数相加
   （3）不可进位，比如0,99,99,99
   （4）依次表示为：0,0,0,0
   （5）每个等级计数之间没关联
   （6）等级判断从左向右，如果某一位数值相同，则判断下一位数值
   （7）如果两个优先级相同，则最后出现的优先级高，!important也适用
   （8）通配符选择器的特殊性值为：0,0,0,0
   （9）继承样式优先级最低，通配符样式优先级高于继承样式
   （10）!important（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0。
   
   计算实例：
   
   （1）#demo a{color: orange;}/*特殊性值：0,1,0,1*/
   （2）div#demo a{color: red;}/*特殊性值：0,1,0,2*/
   
   
   注意：
   （1）样式应用时，css会先查看规则的权重（!important），加了权重的优先级最高，当权重相同的时候，会比较规则的特殊性。
   
   （2）特殊性值越大的声明优先级越高。
   
   （3）相同特殊性值的声明，根据样式引入的顺序，后声明的规则优先级高（距离元素出现最近的）
   
    (4) 部分浏览器由于字节溢出问题出现的进位表现不做考虑
   ```

   

7. ### ::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用。

   ```
   单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）
   双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，
   比如:first-line、:first-letter、:before、:after等，
   而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。
   
   想让插入的内容出现在其它内容前，使用::before，否者，使用::after；
   在代码顺序上，::after生成的内容也比::before生成的内容靠后。
   如果按堆栈视角，::after生成的内容会在::before生成的内容之上。
   ```

8. ### 伪类与伪元素

   ```
   css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。
   
   伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。
   
   伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。
   
   有时你会发现伪元素使用了两个冒号（::）而不是一个冒号（:）。这是CSS3的一部分，并尝试区分伪类和伪元素。大多数浏览器都支持这两个值。按照规则应该使用（::）而不是（:），从而区分伪类和伪元素。但是，由于在旧版本的W3C规范并未对此进行特别区分，因此目前绝大多数的浏览器都支持使用这两种方式表示伪元素。
   ```

9. ### CSS 中哪些属性可以继承？

   ```
   每个CSS属性定义的概述都指出了这个属性是默认继承的，还是默认不继承的。这决定了当你没有为元素的属性指定值时该如何计算值。
   
   当元素的一个继承属性没有指定值时，则取父元素的同属性的计算值。只有文档根元素取该属性的概述中给定的初始值（这里的意思应该是在该属性本身的定义中的默认值）。
   
   当元素的一个非继承属性（在Mozilla code里有时称之为reset property）没有指定值时，则取属性的初始值initial value（该值在该属性的概述里被指定）。
   
   有继承性的属性：
   
   （1）字体系列属性
   font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust
   
   （2）文本系列属性
   text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、
   text-transform、direction、color
   
   （3）表格布局属性
   caption-side border-collapse empty-cells
   
   （4）列表属性
   list-style-type、list-style-image、list-style-position、list-style
   
   （5）光标属性
   cursor
   
   （6）元素可见性
   visibility
   
   （7）还有一些不常用的；speak，page，设置嵌套引用的引号类型quotes等属性
   
   
   注意：当一个属性不是继承属性时，可以使用inherit关键字指定一个属性应从父元素继承它的值，inherit关键字用于显式地指定继承性，可用于任何继承性/非继承性属性。
   ```

10. ### position 的值 relative 和 absolute 定位原点是？

    ```
    absolute
    生成绝对定位的元素，相对于值不为static的第一个父元素的padding box进行定位，也可以理解为离自己这一级元素最近的一级position设置为absolute或者relative的父元素的padding box的左上角为原点的。
    
    fixed（老IE不支持）
    生成绝对定位的元素，相对于浏览器窗口进行定位。
    
    relative
    生成相对定位的元素，相对于其元素本身所在正常位置进行定位。
    
    static
    默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right,z-index声明）。
    
    inherit
    规定从父元素继承position属性的值。
    ```

11. ### li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？

    ```
    浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个<li>放在一行，这导致<li>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。
    
    解决办法：
    
    （1）为<li>设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。
    
    （2）将所有<li>写在同一行。不足：代码不美观。
    
    （3）将<ul>内的字符尺寸直接设为0，即font-size:0。不足：<ul>中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。
    
    （4）消除<ul>的字符间隔letter-spacing:-8px，不足：这也设置了<li>内的字符间隔，因此需要将<li>内的字符间隔设为默认letter-spacing:normal。
    ```

    

12. ### BFC

    https://zhuanlan.zhihu.com/p/25321647#:~:text=Formatting%20context(%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87,%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E7%9B%B8%E4%BA%92%E4%BD%9C%E7%94%A8%E3%80%82&text=BFC%20%E5%8D%B3Block%20Formatting%20Contexts,%E5%AE%9A%E4%BD%8D%E6%96%B9%E6%A1%88%E7%9A%84%E6%99%AE%E9%80%9A%E6%B5%81%E3%80%82

13. ### 清除浮动

    高度塌陷：不清除浮动会发生高度塌陷，浮动元素父元素高度自适应（父元素不写高度时，子元素写了浮动后，父元素会发生高度塌陷）

    - ```css
      clear:both
      ```

    - ```css
      .clearFix:after{
          content:".";
      
          clear:both;
      
          display:block;
      
          height:0;
      
          overflow:hidden;
      
          visibility:hidden;
      
      }
      ```

14. ### margin 重叠问题的理解

    ```
    块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距，这样的现象称为“margin合并”。
    
    产生折叠的必备条件：margin必须是邻接的!
    
    而根据w3c规范，两个margin是邻接的必须满足以下条件：
    
    •必须是处于常规文档流（非float和绝对定位）的块级盒子，并且处于同一个BFC当中。
    •没有线盒，没有空隙，没有padding和border将他们分隔开
    •都属于垂直方向上相邻的外边距，可以是下面任意一种情况
    •元素的margin-top与其第一个常规文档流的子元素的margin-top
    •元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top
    •height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom
    •高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top
    和margin-bottom
    
    
    margin合并的3种场景：
    
    （1）相邻兄弟元素margin合并。
    
    解决办法：
    •设置块状格式化上下文元素（BFC）
    
    （2）父级和第一个/最后一个子元素的margin合并。
    
    解决办法：
    
    对于margin-top合并，可以进行如下操作（满足一个条件即可）：
    •父元素设置为块状格式化上下文元素；
    •父元素设置border-top值；
    •父元素设置padding-top值；
    •父元素和第一个子元素之间添加内联元素进行分隔。
    
    对于margin-bottom合并，可以进行如下操作（满足一个条件即可）：
    •父元素设置为块状格式化上下文元素；
    •父元素设置border-bottom值；
    •父元素设置padding-bottom值；
    •父元素和最后一个子元素之间添加内联元素进行分隔；
    •父元素设置height、min-height或max-height。
    
    （3）空块级元素的margin合并。
    
    解决办法：
    •设置垂直方向的border；
    •设置垂直方向的padding；
    •里面添加内联元素（直接Space键空格是没用的）；
    •设置height或者min-height。
    ```

    

15. ### 布局

    - flex方式布局
    - float方式布局
    - 定位布局
    - 自适应

    

16. ### 居中（垂直居中，水平居中，水平垂直居中）

    - 长宽已知的

    - 长宽未知的（transform）

    - flex

    https://juejin.im/post/6844903560879013901

      

17. ### link标签和import标签的区别

    ```
    1) link属于html标签，而@import是css提供的 
    
    2) 页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。 
    
    3) link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。 
    
    4) link方式样式的权重高于@import的。
    
    5) link可以使用 js 动态引入，@import不行
    ```

    

18. ### flex布局

    http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html

19. ### 媒体查询

    ```
    假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法
    
    当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。当媒体查询返回假，标签上带有媒体查询的样式表仍将被下载（只不过不会被应用）。
    
    包含了一个媒体类型和至少一个使用宽度、高度和颜色等媒体属性来限制样式表范围的表达式。CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。
    ```

20. ### layout viewport、visual viewport 和 ideal viewport 的区别？

    ```
    移动端一共需要理解三个viewport的概念的理解。
    
    第一个视口是布局视口，在移动端显示网页时，由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，那么整
    个页面的布局都会显示错乱。所以移动端浏览器提供了一个layout viewport布局视口的概念，使用这个视口来对页面进行布局展
    示，一般layout viewport的大小为980px，因此页面布局不会有太大的变化，我们可以通过拖动和缩放来查看到这个页面。
    
    第二个视口指的是视觉视口，visual viewport指的是移动设备上我们可见的区域的视口大小，一般为屏幕的分辨率的大小。visu
    al viewport和layout viewport的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口
    中的网页内容。
    
    第三个视口是理想视口，由于layout viewport一般比visual viewport要大，所以想要看到整个页面必须通过拖动和缩放才
    能实现。所以又提出了ideal viewport的概念，ideal viewport下用户不用缩放和滚动条就能够查看到整个页面，并且页面在
    不同分辨率下显示的内容大小相同。ideal viewport其实就是通过修改layout viewport的大小，让它等于设备的宽度，这个
    宽度可以理解为是设备独立像素，因此根据ideal viewport设计的页面，在不同分辨率的屏幕下，显示应该相同。
    ```

    

21. ### css预处理器/后处理器

    ```
    CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件。
    
    预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less csssprite，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。
    
    CSS后处理器是对CSS进行处理，并最终生成CSS的预处理器，它属于广义上的CSS预处理器。我们很久以前就在用CSS后处理器了，最典型的例子是CSS压缩工具（如clean-css），只不过以前没单独拿出来说过。还有最近比较火的Autoprefixer，以CanIUse上的浏览器支持数据为基础，自动处理兼容性问题。
    
    后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。
    ```

22. ### transition 和 animation 的区别

    ```
    transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线。
    
    animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。
    ```

23. ### 为什么 height:100%会无效？

    ```
    对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。
    
    原因是如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto，因为解释成了auto，
    所以无法参与计算。
    
    使用绝对定位的元素会有计算值，即使祖先元素的height计算为auto也是如此。
    ```

24. ### margin:auto 的填充规则

    ```
    margin的'auto'可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发margin:auto计算有一个前提条件，就是width或height为auto时，元素是具有对应方向的自动填充特性的。
    
    （1）如果一侧定值，一侧auto，则auto为剩余空间大小。
    （2）如果两侧均是auto，则平分剩余空间
    ```

25. ### 实现单行／多行文本溢出的省略（...）

    ```css
    /*单行文本溢出*/
    p {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    /*多行文本溢出*/
    p {
      position: relative;
      line-height: 1.5em;
      /*高度为需要显示的行数*行高，比如这里我们显示两行，则为3*/
      height: 3em;
      overflow: hidden;
    }
    
    p:after {
      content: '...';
      position: absolute;
      bottom: 0;
      right: 0;
      background-color: #fff;
    }
    ```

26. ### 三角形

    ```css
    /*三角形的实现原理是利用了元素边框连接处的等分原理。*/
    .triangle {
      width: 0;
      height: 0;
      border-width: 100px;
      border-style: solid;
      border-color: tomatotransparenttransparenttransparent;
    }
    ```

    

27. ### css优化

    ```
    加载性能：
    
    （1）css压缩：将写好的css进行打包压缩，可以减少很多的体积。
    （2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top 0 bottom 0;但margin-bottom:bot
    tom;margin-left:left;执行的效率更高。
    （3）减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。
    
    选择器性能：
    
    （1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；
    
    （2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。
    
    （3）避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。
    
    （4）尽量少的去对标签进行选择，而是用class。
    
    （5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。
    
    （6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。
    
    渲染性能：
    
    （1）慎重使用高性能属性：浮动、定位。
    
    （2）尽量减少页面重排、重绘。
    
    （3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。
    
    （4）属性值为0时，不加单位。
    
    （5）属性值为浮动小数0.**，可以省略小数点之前的0。
    
    （6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。
    
    （7）不使用@import前缀，它会影响css的加载速度。
    
    （8）选择器优化嵌套，尽量避免层级过深。
    
    （9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。
    
    （10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。
    
    （11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。
    
    可维护性、健壮性：
    
    （1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。
    （2）样式与内容分离：将css代码定义到外部css中。
    ```

    

28. ### 浏览器内核

    https://blog.csdn.net/Summer_15/article/details/71249203

    ```
    Trident：这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。
    
    Gecko：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。
    
    Presto：Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢了一部分网页兼容性。
    
    Webkit：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。
    
    Blink：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。
    ```

    

29. ### 主流浏览器内核私有属性 css 前缀？

    ```
     mozilla 内核 （firefox,flock 等）    -moz
     webkit  内核 （safari,chrome 等）   -webkit
     opera   内核 （opera 浏览器）        -o
     trident 内核 （ie 浏览器）           -ms
    ```

    

30. ### 浏览器渲染原理

    https://juejin.im/book/6844733763675488269/section/6844733763771957256

    ```
     （1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。
    
     （2）然后对 CSS 进行解析，生成 CSSOM 规则树。
    
     （3）根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。
    
     （4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
    
     （5）布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。
    
      值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。
    ```

    

31. ### 浏览器解析过程

    ```
     JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。
    
     也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。
    
    ```

32. ### 重绘与回流

    https://juejin.im/post/6844903569087266823

    ```
    重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background-color，我们将这样的操作称为重绘。
     
     回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样
          的操作我们称为回流。
    
     常见引起回流属性和方法：
    
     任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。
    
     （1）添加或者删除可见的 DOM 元素；
     （2）元素尺寸改变——边距、填充、边框、宽度和高度
     （3）内容变化，比如用户在 input 框中输入文字
     （4）浏览器窗口尺寸改变——resize事件发生时
     （5）计算 offsetWidth 和 offsetHeight 属性
     （6）设置 style 属性的值
     （7）当你修改网页的默认字体时。
    
     回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。
    ```

33. ### 语义话html标签

    ```
     我认为 html 语义化主要指的是我们应该使用合适的标签来划分网页内容的结构。html 的本质作用其实就是定义网页文档的结构，一个语义化的文档，能够使页面的结构更加清晰，易于理解。这样不仅有利于开发者的维护和理解，同时也能够使机器对文档内容进行正确的解读。比如说我们常用的 b 标签和 strong 标签，它们在样式上都是文字的加粗，但是 strong 标签拥有强调的语义。
     对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。如果用户使用的是屏幕阅读器来访问网页的话，使用 strong 标签就会有明显的语调上的变化，而 b 标签则没有。如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会依赖于 html 标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的，从而有利于我们网站的 SEO 。从 html5 我们可以看出，标准是倾向于以语义化的方式来构建网页的，比如新增了 header 、footer 这些语义标签，删除了 big 、font 这些没有语义的标签。
    ```

34. ### localStorage,sessionStorage,cookies

    ```
    SessionStorage， LocalStorage， Cookie 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。区别
     在于前两者属于 HTML5 WebStorage，创建它们的目的便于客户端存储数据。而 cookie 是网站为了标示用户身份而储存在用户
     本地终端上的数据（通常经过加密）。cookie 数据始终在同源（协议、主机、端口相同）的 http 请求中携带（即使不需要），会
     在浏览器和服务器间来回传递。
     
     
     存储大小：
       	cookie 数据大小不能超过4 k 。
       	sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。
    
     有期时间：
       	localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。
       	sessionStorage  数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会
                         保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。
       	cookie          设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。
      
     作用域：
         sessionStorage  只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。
         localStorage    在所有同源窗口中都是共享的。
         cookie          在所有同源窗口中都是共享的。
    ```

35. ### 网络验证码解决什么安全问题？

    ```
     （1）区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水
     （2）有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试
    ```

36. ### css的reset 和 normalize.css的区别

    ```
    为什么会有 CSS Reset 的存在呢？那是因为早期的浏览器支持和理解的 CSS 规范不同，导致渲染页面时效果不一致，会出现很多
     兼容性问题。
    
     reset 的目的，是将所有的浏览器的自带样式重置掉，这样更易于保持各浏览器渲染的一致性。
    
     normalize 的理念则是尽量保留浏览器的默认样式，不进行太多的重置，而尽力让这些样式保持一致并尽可能与现代标准相符合。
    
    
     1.Normalize.css 保护了有价值的默认值
    
     Reset 通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。 相比之下，Normalize.css 保持了许多默认的浏
     览器样式。 这就意味着你不用再为所有公共的排版元素重新设置样式。 当一个元素在不同的浏览器中有不同的默认值时，Normali
     ze.css 会力求让这些样式保持一致并尽可能与现代标准相符合。
    
    
     2.Normalize.css 修复了浏览器的 bug
    
     它修复了常见的桌面端和移动端浏览器的 bug。这往往超出了 Reset 所能做到的范畴。关于这一点，Normalize.css 修复的问题
     包含了 HTML5 元素的显示设置、预格式化文字的 font-size 问题、在 IE9 中 SVG 的溢出、许多出现在各浏览器和操作系统中的与表单相关的 bug。
    
    
     3.Normalize.css 没有复杂的继承链
    
     使用 Reset 最让人困扰的地方莫过于在浏览器调试工具中大段大段的继承链。在 Normalize.css 中就不会有这样的问题，因为在
     我们的准则中对多选择器的使用时非常谨慎的，我们仅会有目的地对目标元素设置样式。
    
    
     4.Normalize.css 是模块化的
    
     这个项目已经被拆分为多个相关却又独立的部分，这使得你能够很容易也很清楚地知道哪些元素被设置了特定的值。因此这能让你自己
     选择性地移除掉某些永远不会用到部分（比如表单的一般化）。
    
    
     5.Normalize.css 拥有详细的文档
    
     Normalize.css 的代码基于详细而全面的跨浏览器研究与测试。这个文件中拥有详细的代码说明并在 Github Wiki 中有进一步的
     说明。这意味着你可以找到每一行代码具体完成了什么工作、为什么要写这句代码、浏览器之间的差异，并且你可以更容易地进行自己
     的测试。
    ```

37. ### 前端性能优化

    ```
    前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。
    
     第一个方面是页面的内容方面
    
     （1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。
    
     （2）通过 DNS 缓存等机制来减少 DNS 的查询次数。
    
     （3）通过设置缓存策略，对常用不变的资源进行缓存。
    
     （4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。
    
     （5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。
    
     第二个方面是服务器方面
    
     （1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。
    
     （2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。
    
     （3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie
    
     第三个方面是 CSS 和 JavaScript 方面
    
     （1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。
    
     （2）避免使用 @import 标签。
    
     （3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。
    
     （4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。
    ```

38. ### 在 js 中不同进制数字的表示方式

    ```
    以 0X、0x 开头的表示为十六进制。
    
    以 0、0O、0o 开头的表示为八进制。
    
    以 0B、0b 开头的表示为二进制格式。
    ```

39. ### 其他值转换到字符串的规则

    ```
    （1）Null 和 Undefined 类型 ，null 转换为 "null"，undefined 转换为 "undefined"，
    
    （2）Boolean 类型，true 转换为 "true"，false 转换为 "false"。
    
    （3）Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。
    
    （4）Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。
    
    （3）对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString（（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如"[object Object]"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。
    ```

40. ### 什么情况下会发生布尔值的隐式强制类型转换

    ```
    （1） if (..) 语句中的条件判断表达式。
    （2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。
    （3） while (..) 和 do..while(..) 循环中的条件判断表达式。
    （4） ? : 中的条件判断表达式。
    （5） 逻辑运算符 ||（逻辑或）和 &&（逻辑与）左边的操作数（作为条件判断表达式）。
    ```

41. ### || 和 && 操作符的返回值

    ```
    || 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。
    
    对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。
    
    && 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。
    
    || 和 && 返回它们其中一个操作数的值，而非条件判断的结果
    ```

42. ### == 操作符的强制类型转换规则

    ```
    （1）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。
    
    （2）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。
    
    （3）null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。
    
    （4）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。
    
    （5）如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。
    
    （6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。
    ```

43. ### 为什么 0.1 + 0.2 != 0.3？如何解决这个问题

    ```
    当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。
    
    对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。
    
    我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以使用 es6 的 Number.EPSILON
    ```

    

44. ### 常用正则

    https://www.jianshu.com/p/1cb5229325a7

    

45. ### 数组方法

    ```
    数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。
    
    数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。
    
    数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。
    
    数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。
    
    数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。
    
    数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法
    
    数组归并方法 reduce() 和 reduceRight() 方法
    
    ```

    

46. ### 变量提升

    ```
    变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。
    
    造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。
    ```

    

47. ### 同步异步

    https://blog.csdn.net/tennysonsky/article/details/45111623

    ```
    同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。
    
    异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。
    ```

    

48. ### 什么是 DOM 和 BOM

    ```
    DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。
    
    BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM
    的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）
    对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati
    on 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对
    象的子对象。
    ```

    

49. ### 绑定DOM事件

    https://blog.csdn.net/u013217071/article/details/77613706

50. ### DOM 操作——怎样添加、移除、移动、复制、创建和查找节点

    （1）创建新节点

    ```js
    createDocumentFragment(node);
    createElement(node);
    createTextNode(text);
    ```

    （2）添加、移除、替换、插入

    ```js
    appendChild(node)
    removeChild(node)
    replaceChild(new,old)
    insertBefore(new,old)
    ```

    （3）查找

    ```js
    getElementById();
    getElementsByName();
    getElementsByTagName();
    getElementsByClassName();
    querySelector();
    querySelectorAll();
    ```

    （4）属性操作

    ```js
    getAttribute(key);
    setAttribute(key, value);
    hasAttribute(key);
    removeAttribute(key);
    ```

    

51. ### this指向

    http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bthis%E8%AF%A6%E8%A7%A3.html

    ```
    1.第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。
    
    2.第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。
    
    3.第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。
    
    4.第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。
    ```

    

52. ### 闭包

    https://github.com/YvetteLau/Step-By-Step/issues/24

53. ### 严格模式

    https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode

54. ### new一个对象过程

    ```js
    // （1）首先创建了一个新的空对象
    // （2）设置原型，将对象的原型设置为函数的 prototype 对象。
    // （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
    // （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。
    
    // 实现:
    
    function objectFactory() {
      let newObject = null,
        constructor = Array.prototype.shift.call(arguments),
        result = null;
    
      // 参数判断
      if (typeof constructor !== "function") {
        console.error("type error");
        return;
      }
    
      // 新建一个空对象，对象的原型为构造函数的 prototype 对象
      newObject = Object.create(constructor.prototype);
    
      // 将 this 指向新建对象，并执行函数
      result = constructor.apply(newObject, arguments);
    
      // 判断返回对象
      let flag =
        result && (typeof result === "object" || typeof result === "function");
    
      // 判断返回结果
      return flag ? result : newObject;
    }
    
    // 使用方法
    // objectFactory(构造函数, 初始化参数);
    ```

55. ### json

    ```
    JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。
    
    在项目开发中，我们使用 JSON 作为前后端数据交换的方式。在前端我们通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。
    
    因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是我们应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。
    
    在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，一个是 JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 JSON 格式的字符串。
    
    另一个函数 JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当我们从后端接收到 JSON 格式的字符串时，我们可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。
    ```

    

56. ### 原型与原型链

    http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html

57. ### JavaScript 继承的几种实现方式

    ```
    我了解的 js 中实现继承的几种方式有：
    
    （1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。
    
    （2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。
    
    （3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。
    
    （4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。
    
    （5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。
    
    （6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。
    ```

    

58. ### 回调地狱 promise，（async，await）

    https://juejin.im/post/6844903600444047368

59. ### 深浅拷贝

    ```js
    // 浅拷贝的实现;
    
    function shallowCopy(object) {
      // 只拷贝对象
      if (!object || typeof object !== "object") return;
    
      // 根据 object 的类型判断是新建一个数组还是对象
      let newObject = Array.isArray(object) ? [] : {};
    
      // 遍历 object，并且判断是 object 的属性才拷贝
      for (let key in object) {
        if (object.hasOwnProperty(key)) {
          newObject[key] = object[key];
        }
      }
    
      return newObject;
    }
    
    // 深拷贝的实现;
    
    function deepCopy(object) {
      if (!object || typeof object !== "object") return;
    
      let newObject = Array.isArray(object) ? [] : {};
    
      for (let key in object) {
        if (object.hasOwnProperty(key)) {
          newObject[key] =
            typeof object[key] === "object" ? deepCopy(object[key]) : object[key];
        }
      }
    
      return newObject;
    }
    ```

    ```
    浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。
    
    深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。
    ```

    

60. ### 跨域

    https://segmentfault.com/a/1190000015597029

61. ### 事件流，事件委托

    https://zhuanlan.zhihu.com/p/26536815

    ```
    事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到
    目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。
    
    使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。
    ```

    

62. ### 什么是 Polyfill 

    ```
    Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。
    
    比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。
    
    一个 shim 是一个库，有自己的 API，而不是单纯实现原生不支持的 API。
    ```

    

63. ### es6语法（https://es6.ruanyifeng.com/）

    - ##### var let const

    - ##### 箭头函数

    - ##### 解构

    - ##### `${}`

    - ##### set 与 map

    - ##### for...in

    - .........

64. ### Class

    ```
    ES6 新添加的 class 只是为了补充 js 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 class 可以有利于我们更好的组织代码。
    
    在 class 中添加的方法，其实是添加在类的原型上的。
    ```

65. ### 前端路由

    ```
    （1）什么是前端路由？
    
    前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。
    
    （2）什么时候使用前端路由？
    
    在单页面应用，大部分页面结构不变，只改变部分内容的使用
    
    （3）前端路由有什么优点和缺点？
    
    优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户
    
    缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置
    
    前端路由一共有两种实现方式，一种是通过 hash 的方式，一种是通过使用 pushState 的方式。
    
    ```

    

66. ### 事件循环，宏任务与微任务

    https://juejin.im/post/6844903606466904078

    https://juejin.im/post/6844903512845860872

    ```
    因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。
    
    微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。
    
    宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲
    染等。
    ```

    

67. ### call apply bind

    https://juejin.im/post/6844903567967387656

68. ### 防抖与节流

    ```js
    // 函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。
    
    // 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。
    
    // 函数防抖的实现
    function debounce(fn, wait) {
      var timer = null;
    
      return function() {
        var context = this,
          args = arguments;
    
        // 如果此时存在定时器的话，则取消之前的定时器重新记时
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
    
        // 设置定时器，使事件间隔指定事件后执行
        timer = setTimeout(() => {
          fn.apply(context, args);
        }, wait);
      };
    }
    
    // 函数节流的实现;
    function throttle(fn, delay) {
      var preTime = Date.now();
    
      return function() {
        var context = this,
          args = arguments,
          nowTime = Date.now();
    
        // 如果两次时间间隔超过了指定时间，则执行函数。
        if (nowTime - preTime >= delay) {
          preTime = Date.now();
          return fn.apply(context, args);
        }
      };
    }
    
    ```

    

69. ### 快速排序，冒泡排序，选择排序，插入排序

70. ### 浏览器缓存机制

    https://juejin.im/entry/6844903593275817998

71. ### http与https

    https://zhuanlan.zhihu.com/p/72616216

72. ### 三次握手，四次挥手

    https://zhuanlan.zhihu.com/p/53374516

    

73. ### 常用库，moment，lodash等

74. ### get 请求传参长度的误区

    ```
    1.HTTP 协议未规定 GET 和 POST 的长度限制
    2.GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度
    3.不同的浏览器和 WEB 服务器，限制的最大长度不一样
    4.要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte
    ```

    

75. ### URL 和 URI 的区别

    ```
    URI: Uniform Resource Identifier      指的是统一资源标识符
    URL: Uniform Resource Location        指的是统一资源定位符
    URN: Universal Resource Name          指的是统一资源名称
    
    URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。
    
    URL 指的是统一资源定位符，URN 指的是统一资源名称。URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。
    ```

    

77. token加密是怎么一回事？

    ```
    简单来说就是一个身份证，每次发送请求都带着这个身份证让后端进行身份的验证。
    需要一个 secret（随机数）；
    后端利用 secret 和加密算法（如：HMAC-SHA256）对 payload（如账号密码）生成一个字符串（token），返回前端；
    前端每次 request 在 header 中带上 token;
    后端用同样的算法解密；
    ```

78. http1.0,1.1,2.0的区别

    https://juejin.im/entry/6844903489596833800
    
78. 长连接与短连接

    https://developer.aliyun.com/article/37987

    ```
    http1.1之后默认为长连接，和上文最后结论是否相悖？
    其实不相悖，可以想象一个场景：当你请求一个网页的时候，会获取各种资源（图片，script，css...），这些都是发送到服务器端的，而这些都通过同一个tcp长连接获取，而不是短连接。
    ```

79. http状态码

    ```
    100~199: 信息提示
    
    200~299：成功
    
    300~399：重定向
    
    400~499：客户端错误
    
    500~599：服务端错误
    
    200 成功
    204 无内容
    301 永久移动（回应 GET 响应时会自动将请求者转到新位置）
    304 未修改（协商缓存）
    400 Bad Request
    401 未授权
    403 服务器拒绝请求
    404 未找到
    409 请求发生冲突
    500 服务器内部错误
    502 错误网关
    503 服务不可用
    ```

80. 输入url后，浏览器做了什么？

    ```
    浏览器获取用户输入，等待 url 输入完毕，触发 enter 事件；
    解析 URL，分析协议头，再分析主机名是域名还是 IP 地址；
    如果主机名是域名的话，则发送一个 DNS 查询请求到 DNS 服务器，获得主机 IP 地址；
    使用 DNS 获取到主机 IP 地址后，向目的地址发送一个（http/https/protocol）请求，并且在网络套接字上自动添加端口信息（http 80 https 443）；
    等待服务器响应结果；
    将响应结果（html）经浏览器引擎解析后得到 Render tree，浏览器将 Render tree 进行渲染后显示在显示器中，用户此时可以看到页面被渲染。
    ```

81. CDN是什么？

    ```
    CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供资源就近访问的功能。也就是说，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CDN 服务器将请求定位到最近的含有该资源的服务器上去请求。这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。
    ```

82. Nodejs更适合i/o密集型还是cpu密集型任务？为什么？

    ```
    Node 更适合处理 I/O 密集型的任务。因为 Node 的 I/O 密集型任务可以异步调用，利用事件循环的处理能力，资源占用极少，并且事件循环能力避开了多线程的调用，在调用方面是单线程，内部处理其实是多线程的。
    
    并且由于 Javascript 是单线程的原因，Node 不适合处理 CPU 密集型的任务，CPU 密集型的任务会导致 CPU 时间片不能释放，使得后续 I/O 无法发起，从而造成阻塞
    ```

83. 什么是懒加载

    ```
    
    懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式。
    
    懒加载的优点：
    
    提升用户体验，加快首屏渲染速度；
    减少无效资源的加载；
    防止并发加载的资源过多会阻塞 js 的加载；
    懒加载的原理：
    
    首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在 data-original 属性中，当页面滚动的时候需要去监听 scroll 事件，在 scroll 事件的回调中，判断我们的懒加载的图片是否进入可视区域，如果图片在可视区内则将图片的 src 属性设置为 data-original 的值，这样就可以实现延迟加载
    ```

    原生基本实现：https://zhuanlan.zhihu.com/p/55311726（可优化）

    浏览器支持：https://www.zhangxinxu.com/wordpress/2019/09/native-img-loading-lazy/

84. webpack 中 loader 和 plugin 的区别是什么？

    ```
    loader：loader 是一个转换器，将 A 文件进行编译成 B 文件，属于单纯的文件转换过程；
    
    plugin：plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。
    ```

85. CMD&AMD&Commonjs,webpack

    https://juejin.im/post/6844903541853650951

    https://webpack.js.org/concepts/modules/

86. 

